name: Deploy Production
on:
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"

permissions:
  contents: read
  packages: write
  actions: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Get version from tag
        id: get_version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            echo "VERSION=${VERSION}" >> $GITHUB_ENV
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "Error: No valid tag found!" >&2
            exit 1
          fi

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/prod/prod.Dockerfile
          push: true
          tags: |
            ghcr.io/ardiman-xyz/fkip_web_app:${{ env.VERSION }}
            ghcr.io/ardiman-xyz/fkip_web_app:stable
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /var/www/html/docker/web-fkip/prod

            # Update environment variables
            if grep -q "APP_VERSION=" .env; then
              sed -i "s/APP_VERSION=.*/APP_VERSION=${{ env.VERSION }}/" .env
            else
              echo "APP_VERSION=${{ env.VERSION }}" >> .env
            fi

            if grep -q "APP_ENV=" .env; then
              sed -i "s/APP_ENV=.*/APP_ENV=production/" .env
            else
              echo "APP_ENV=production" >> .env
            fi

            # Pull latest images with retry
            for i in {1..3}; do
              if docker compose pull; then
                break
              fi
              echo "Pull attempt $i failed, retrying..."
              sleep 10
            done

            # Clean up old images
            docker image prune -f

            # Stop and remove existing containers properly
            docker compose -p fkip down --remove-orphans

            # Make sure the container is really gone before recreating
            if docker ps -a --format "table {{.Names}}" | grep -q "fkip_web_prod"; then
              docker rm -f fkip_web_prod
            fi

            # Start containers with new images
            docker compose -p fkip up -d

            # Wait for the container to be fully started
            echo "Waiting for container to be ready..."

            # More robust approach for checking if container is ready
            for i in {1..30}; do
              if docker compose -p fkip ps --format "table {{.Service}}\t{{.Status}}" | grep -q "app.*running"; then
                echo "Container is running!"
                
                # Additional health check
                if docker compose -p fkip exec -T app php -v > /dev/null 2>&1; then
                  echo "PHP is working correctly!"
                  break
                fi
              fi
              
              if [ $i -eq 30 ]; then
                echo "Container failed to start within timeout"
                docker compose -p fkip logs app
                exit 1
              fi
              
              echo "Waiting for container... attempt $i/30"
              sleep 5
            done

            # Show final status
            docker compose -p fkip ps
            echo "Deployment completed successfully!"
